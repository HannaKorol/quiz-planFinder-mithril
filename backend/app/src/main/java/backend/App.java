/*
 * This Java source file was generated by the Gradle 'init' task.
 *
 * Этот сервлет реализует простой JSON API, возвращающий данные о тарифных планах. Он доступен по маршруту /plan-details, разрешает кросс-доменные GET-запросы, и может быть использован как часть публичного REST-сервиса.
 *  we’ll include  jakarta.servlet-api
 */


package backend;                                                                 // ты положил свой документ в папку backend на компьютере, и теперь знаешь, где его искать.

//Импорт библиотек Jetty:
import jakarta.servlet.http.HttpServlet;                                       //форма (сервлет), которая эти письма принимает и пишет ответы
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.eclipse.jetty.server.*;                                            //Импортируем всё, что нужно от сервера Jetty

import java.io.IOException;                                                  //Может произойти ошибка при работе с текстом или сетью — говорим Java, что мы готовы к этому.

import org.eclipse.jetty.ee10.servlet.ServletContextHandler;

public class App {

	public static void main(String[] args) throws Exception {
		/*System.out.println(new App().getGreeting()); */                        //System.out.println()-  выводит строку "Hello World!" в консоль. Метод getGreeting() возвращает строку "Hello World!".

		//Создаем сервер на порту 9999
		Server server = new Server(9999);                                   //создание нового объекта сервера, который будет слушать порт 9999.
		ServerConnector connector = new ServerConnector(server);                 // создается соединение с сервером.
		server.addConnector(connector);                                          //подключаем созданный connector к серверу, чтобы сервер начал принимать запросы через этот соединитель.

		ServletContextHandler context = new ServletContextHandler();            //управляет контекстом сервлетов (областью, в которой обрабатываются HTTP-запросы). Это основа для настройки маршрутов сервлетов в веб-приложении.
		context.setContextPath("/");                                            //Устанавливается корневой путь ("/") для контекста. Это означает, что все URL-запросы будут начинаться с корня веб-приложения. Если бы путь был, например, "/api", все маршруты работали бы как /api/....
		context.addServlet(PlanDetailsServlet.class, "/plan-details");  //К контексту добавляется сервлет PlanDetailsServlet, который будет обрабатывать HTTP-запросы, отправленные по пути /plan-details. Это значит, что при переходе на URL http://localhost:9999/plan-details будет вызываться логика, реализованная в классе PlanDetailsServlet.

		server.setHandler(context);                                               //Устанавливается обработчик (handler) для сервера. В данном случае это context, то есть ServletContextHandler, настроенный ранее. Это значит, что сервер будет использовать заданный контекст для обработки входящих HTTP-запросов.

		//Установка обработчика
		server.start();                                                           //Запускается сервер. С этого момента он начинает прослушивать указанный порт и обрабатывать входящие соединения.
		server.join();                                                            //Ожидание завершения работы сервера. Этот вызов блокирует текущий поток (обычно главный поток приложения) и не позволяет программе завершиться, пока сервер работает. Это нужно, чтобы сервер продолжал обслуживать запросы, а приложение не завершилось сразу после запуска.
	}
	                         //Когда все настроено, мы запускаем сервер Jetty через Gradle, и он будет слушать HTTP-запросы на порту, например, localhost:9999.

	public static class PlanDetailsServlet extends HttpServlet {                  //Определяется вложенный (static) класс PlanDetailsServlet, который расширяет HttpServlet. Это значит, что этот класс будет обрабатывать HTTP-запросы. В данном случае — метод GET.
		@Override
		public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {      //Переопределяется метод doGet, который вызывается при получении HTTP GET-запроса. Аргументы req и resp — это объекты запроса и ответа соответственно.
			resp.setStatus(HttpServletResponse.SC_OK);                                                //Устанавливается статус ответа 200 OK, что означает успешную обработку запроса.
			resp.setHeader("Access-Control-Allow-Origin", "*");                            //Добавляется заголовок CORS, разрешающий доступ к ресурсу с любых доменов. Это полезно, если мой API будет использоваться с разных источников, например, с фронтенда, размещённого на другом домене.
			resp.setHeader("Access-Control-Allow-Methods", "GET");                         //Указывается, что разрешён только метод GET для кросс-доменных запросов.
			resp.setContentType("application/json");                                                  //Устанавливаются заголовки, сообщающие клиенту, что возвращаемый контент — это JSON
			resp.setCharacterEncoding("UTF-8");                                                       //в кодировке UTF-8
			                                                                                          //Создаётся многострочная строка в формате JSON, содержащая информацию о различных тарифных планах. Это удобно для передачи структурированных данных в ответе.
			String json = """
					{
					                          "Free": {
					                            "usage": "for personal use",
					                            "storage": "1 GB storage",
					                            "labels": "3 labels",
					                            "calendars": "1 calendar"
					                          },
					                          "Revolutionary": {
					                            "usage": "for personal use",
					                            "emails": "15 additional email addresses",
					                            "storage": "20 GB storage",
					                            "domains": "3 custom domains",
					                            "calendars": "Unlimited calendars",
					                            "labels": "Unlimited labels",
					                            "family": "Family option"
					                          },
					                          "Legend": {
					                            "usage": "for personal use",
					                            "emails": "30 additional email addresses",
					                            "storage": "500 GB storage",
					                            "domains": "10 custom domains",
					                            "calendars": "Unlimited calendars",
					                            "labels": "Unlimited labels",
					                            "family": "Family option"
					                          },
					                          "Essential": {
					                            "usage": "for business purposes",
					                            "emails": "15 additional email addresses",
					                            "storage": "50 GB storage",
					                            "domains": "3 custom domains",
					                            "calendars": "Unlimited calendars",
					                            "labels": "Unlimited labels"
					                          },
					                          "Advanced": {
					                            "usage": "for business purposes",
					                            "emails": "30 additional email addresses",
					                            "storage": "500 GB storage",
					                            "domains": "10 custom domains",
					                            "calendars": "Unlimited calendars",
					                            "labels": "Unlimited labels"
					                          },
					                          "Unlimited": {
					                            "usage": "for business purposes",
					                            "emails": "30 additional email addresses",
					                            "storage": "1000 GB storage",
					                            "domains": "Unlimited domains",
					                            "calendars": "Unlimited calendars",
					                            "labels": "Unlimited labels"
					                          }
					                        }
					""";
			resp.getWriter().write(json);                                                                                 //Отправка JSON-строки в теле ответа клиенту. Write the JSON object or array to the response using the response.getWriter() method:
		}
	}
}



/*
* USEFUL LINKS:
* 1) https://www.baeldung.com/jetty-embedded - Embedded Jetty Server in Java
* 2) https://www.baeldung.com/servlet-json-response - Returning a JSON Response from a Servlet
* 3) https://stackoverflow.com/questions/2010990/how-do-you-return-a-json-object-from-a-java-servlet - How do you return a JSON object from a Java Servlet
* 4) https://stackoverflow.com/questions/477816/which-json-content-type-do-i-use - Which JSON content type do I use?
* 5) https://codingtechroom.com/question/-embed-jetty-server-json-xml-responses - How to Embed Jetty Server and Handle JSON/XML Responses
* 6) https://localhorse.net/article/differences-between-javax-and-jakarta - Key Differences Between Javax and Jakarta
* 7) https://stackoverflow.com/questions/13489139/how-to-write-json-string-value-in-code - How to write JSON string value in code?
* 7) https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/#raw-string-literals - Strings and string literals
 * */



